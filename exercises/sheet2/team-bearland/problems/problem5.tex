\textbf{\textit{(5) Let $\cT=\{\sigma_1,\dots,\sigma_m\}$ be a triangulation of a full-dimensional point configuration $\cA=(\aaa_1,\dots,\aaa_n)\subset\RR^d$ of $n$~points, where we consider the $\sigma_i\in\binom{[n]}{d+1}$ to be index sets. Let $R^{\text{int}}$ be the set of interior ridges, defined to be intersections $\rho = \rho_{ij} = \sigma_i\cap\sigma_j$ of two facets of~$\cT$ such that the affine span of the points of~$\cA$ indexed by~$\rho$ has dimension~$d-1$. (In the triangulations of~Figure~\ref{fig:triangs1}, they are the interior edges.)}}

  \begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[scale=.4]
      \coordinate (1) at (0,0);
      \coordinate (2) at (12,-1);
      \coordinate (3) at (6,9);
      \coordinate (4) at (3,1.5);
      \coordinate (5) at (9,1.5);
      \coordinate (6) at (6,6);

      \draw[very thick] (1)--(2)--(3)--(1)--(4)--(5)--(6)--(4);
      \draw[very thick] (2)--(5);
      \draw[very thick] (3)--(6);

      \draw[very thick] (1)--(5);
      \draw[very thick] (2)--(6);
      \draw[very thick] (3)--(4);
    \end{tikzpicture}
    \qquad
    \begin{tikzpicture}[scale=.4]
      \coordinate (1) at (0,0);
      \coordinate (2) at (12,-1);
      \coordinate (3) at (6,9);
      \coordinate (4) at (3,1.5);
      \coordinate (5) at (9,1.5);
      \coordinate (6) at (6,6);

      \draw[very thick] (1)--(2)--(3)--(1)--(4)--(5)--(6)--(4);
      \draw[very thick] (2)--(5);
      \draw[very thick] (3)--(6);

      \draw[very thick] (2)--(4);
      \draw[very thick] (3)--(5);
      \draw[very thick] (1)--(6);
    \end{tikzpicture}    
    \caption{Two triangulations.
    View the source code for the coordinates of the points.}
    \label{fig:triangs1}
  \end{figure}

\begin{enumerate}
  \item
      \textbf{\textit{For a vector $\omega\in\RR^n$, lift the points in $\cA$ to heights~$\omega$, so that $\cA^\omega=\big(\binom{\aaa_1}{\omega_1},\dots,\binom{\aaa_n}{\omega_n}\big)$. For each interior ridge $\rho=\sigma_i\cap\sigma_j\in R^{\text{int}}$, formulate the folding condition that expresses that $\rho$ indexes a face of the lower convex hull of~$\cA^\omega$, in terms of the coordinates of the~$\aaa_i$ and~$\omega$. Your folding condition should be an inequality that is linear in each height~$\omega_i$.}}

To formulate the folding condition, we make use of Definition 7.4 in Rheka R. Thomas~\footnote{Rekha R. Thomas. Lectures in geometric combinatorics., volume 33 of Student Mathematical Library. Providence, RI: American Mathematical Society (AMS); Princeton, NJ: Institute for Advanced Studies, 2006.}:
        \begin{equation*}
            \begin{split}
                \rho \text{ indexes a face of the lower convex hull of } \cA^\omega & \Leftrightarrow \rho \text{ indexes a folded face of the regular subdivision } \\
                & \Leftrightarrow \exists \pmb{y} \in \mathbb{R}^{d} \text{ s.t. } \left\lbrace \begin{array}{l} (\pmb{y}, -1) \cdot (\pmb{a_j}, \omega_j)^t = 0 \forall j \in \rho \\ (\pmb{y}, -1) \cdot (\pmb{a_j}, \omega_j)^t < 0 \forall j \not\in \rho \end{array} \right.
            \end{split}
        \end{equation*}
    geometrically, this means that $(\pmb{y}, -1)$ is normal to the face $\rho$ is indexing (in the lifted configuration) and all other points lie \textit{above} it.
    Note that, in contrast to the example in Rheka Thomas, $\rho$ does not index a face of the regular subdivision since it's affine span has dimension $d-1$. 
    In this case, the face in the lifted configuration \textit{folds} to a ridge in the original point configuration.

  \item
        \textbf{\textit{Write code that takes the coordinates of the $\aaa_i$ and the facets $\sigma_i$ of a triangulation as input, and outputs the set of folding conditions in a text file in LP file format.}}

    We install the \texttt{gurobi} software distribution using an academic license, and use it's Python API to generate a model file in LP file format and to later solve it.
    A single \textsc{Python3} script reads the vertices and triangulation files, generates the model, outputs it to a file in the LP file format, and solves it (if such a solution exists).
    The whole source code can be found in the \texttt{src/} directory.
    In Listing~\ref{listing:model-generation} we include the method to generate the model using the \texttt{gurobi} library.
        \begin{lstlisting}[style=python,caption={Code to generate the set of folding conditions given a point configuration and a triangulation.\label{listing:model-generation}}]
            import gurobipy as gp

            # Omitted Lines

            def generate_lp(point_config, triangulation):
                model = gp.Model('folding')
                print(point_config)
                print(triangulation)
                # Add Weight Vector: GRB.CONTINUOUS vars are by default [0, \inf)
                w = model.addVars(range(int(point_config.num_points)), vtype=GRB.CONTINUOUS,
                        name='w')
                # Add Constrains
                for num, c in enumerate(triangulation.facets):
                    facet_ind = set([int(i) for i in c])
                    # For each facet, there must exist y
                    y = model.addVars(range(int(point_config.dim)), 
                            lb=-GRB.INFINITY, ub=GRB.INFINITY,
                            vtype=GRB.CONTINUOUS,
                            name='y{}'.format(num))
                    non_facet_ind = set(range(int(point_config.num_points))) - facet_ind 
                    print(" -- Constrain for Facet {} -- ".format(num))
                    print("Facet: {}\nNon-Facet: {}".format(facet_ind, non_facet_ind))
                    # Adding one constrain per vertex in the facet
                    for num2, vert in enumerate(facet_ind):
                        model.addConstr(gp.quicksum([y[i]*point_config.points[vert][i] 
                                                    for i in range(int(point_config.dim))])
                                        - w[vert], GRB.EQUAL, 0, "f{}_{}".format(num, num2))
                    # Adding one constrain per non-vertex in the facet
                    for num2, vert in enumerate(non_facet_ind):
                        model.addConstr(gp.quicksum([y[i]*point_config.points[vert][i] 
                                                    for i in range(int(point_config.dim))])
                                        - w[vert], GRB.LESS_EQUAL, -0.00001, "nf{}_{}".format(num, num2))
                model.write('folding.lp')
                return model
        \end{lstlisting}
        Note that we add a constrain per point per each triangulation.
        Lastly, in the submission we include the output generated by our code when ran with \texttt{4-cube.vertices} and \texttt{4-cube.triangulation} as input parameters (equivalent to running \texttt{run.sh}) in the \texttt{folding.lp} (not included due to its length).

  \item
      \textbf{\textit{Download a linear programming software such as \texttt{gurobi}, \texttt{cplex} or \texttt{scip}/\texttt{soplex} and check explicitly whether there exists a choice of heights $\omega$ that induces each of the triangulations of Figure~\ref{fig:triangs1}.}}

        Firstly, and using the coordinates from the figure source, we write the vertices and triangulation files for the left and right configuration in Figure~\ref{fig:triangs1}.
        They are also included in the submission in the \texttt{src} directory.

        Checking if there exists a choice of heights that induces a given triangulation, is equivalent to finding a weight vector $\pmb{w}$ that satifies all the inequalities generated by the code presented in exercise 2.
        We are only interested in existance, and hence in knowing wether the problem is feasible or not.
        In particular, we are dealing with a Constraint Satisfaction Problem (CSP).

        To check the feasibility of the problem, we make use of the \texttt{model.optimize()} method available in Gurobi's Python API, where the model definition is the one presented in Listing~\ref{listing:model-generation}.
        In particular, we don't set an objective function.
        Listing~\ref{listing:model-optimization} presents how we do so:
        \begin{lstlisting}[style=python,caption={Model definition and optimization.\label{listing:model-optimization}}]
        if __name__=="__main__":
            if (len(sys.argv) != 3 or sys.argv[1].split('.')[-1] != "vertices"
                    or sys.argv[2].split('.')[-1] != "triangulation"):
                usage()
            else:
                point_config = PointConfig(sys.argv[1])
                triangulation = Triangulation(sys.argv[2])
                model = generate_lp(point_config, triangulation)
                # Optimize
                model.optimize()
                status = model.status
                if status == GRB.INFEASIBLE:
                    print('The model is infeasible.')
                    exit(0)
                if status == GRB.OPTIMAL:
                    print(model.getAttr('X', model.getVars()))
                    exit(0)
        \end{lstlisting}

        Using this code, we check that the configuration in Figure~\ref{fig:triangs1}-left is non-regular (unfeasible problem) and the one in Figure~\ref{fig:triangs1}-right as well.
  \item
      \textbf{\textit{Using this code, check that the triangulation of the $4$-dimensional cube given by the files \texttt{4-cube.vertices} and \texttt{4-cube.triangulation} is non-regular, i.e., it does not come from a lifting to~$\RR^5$. If you like, download and play with TOPCOM.}}

      To check that the 4D cube is non-regular, and as a consequence does not come from a lifting to $\RR^5$ it suddices to check that there does not exist a choice of heights $\pmb{w}$ for which such triangulation could be induced.

      Equivalently, we can feed our code with the point configuration and triangulation files, and check whether the optimization problem is feasible or not.
      Doing so, we observe that the problem \textbf{is not} feasible, therefore the 4-dimensional cube is non-regular.
  \end{enumerate}
